# This file is automatically generated. See `src/frontend/test_runner/README.md` for more information.
- sql: |
    create table t (v1 bigint, v2 double precision);
    select v1 from (select * from t) where v2 > 1;
  logical_plan: |
    LogicalProject { exprs: [$0] }
      LogicalFilter { predicate: ($1 > 1:Int32) }
        LogicalProject { exprs: [$1, $2] }
          LogicalScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    /* merge and then eliminate */
    create table t (v1 bigint, v2 double precision);
    select a1 as v1, a2 as v2 from (select v1 as a1, v2 as a2 from t);
  logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalProject { exprs: [$1, $2] }
        LogicalScan { table: t, columns: [_row_id, v1, v2] }
  optimized_logical_plan: |
    LogicalScan { table: t, columns: [v1, v2] }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select v1 from (select v2, v1 as v3 from t) where v2 > 1;
  binder_error: 'Item not found: Invalid column: v1'
- sql: |
    create table t (v1 bigint, v2 double precision);
    select v3 from (select v2, v1 as v3 from t) where v2 > 1;
  logical_plan: |
    LogicalProject { exprs: [$1] }
      LogicalFilter { predicate: ($0 > 1:Int32) }
        LogicalProject { exprs: [$2, $1] }
          LogicalScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    /* consecutive projects are merged */
    create table t (v1 bigint, v2 double precision);
    select v1, 2 from (select v1, v2, 1 from t);
  logical_plan: |
    LogicalProject { exprs: [$0, 2:Int32] }
      LogicalProject { exprs: [$1, $2, 1:Int32] }
        LogicalScan { table: t, columns: [_row_id, v1, v2] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0, 2:Int32] }
      LogicalScan { table: t, columns: [v1] }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select * from (select * from t);
  logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalProject { exprs: [$1, $2] }
        LogicalScan { table: t, columns: [_row_id, v1, v2] }
  optimized_logical_plan: |
    LogicalScan { table: t, columns: [v1, v2] }
- sql: |
    /* joins */
    create table t (v1 bigint, v2 double precision);
    select * from (select * from t), t;
  logical_plan: |
    LogicalProject { exprs: [$0, $1, $3, $4] }
      LogicalJoin { type: Inner, on: true, output_indices: all }
        LogicalProject { exprs: [$1, $2] }
          LogicalScan { table: t, columns: [_row_id, v1, v2] }
        LogicalScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    /* table alias */
    create table t (v1 bigint, v2 double precision);
    select * from (select * from t) as tt join t on tt.v1=t.v1;
  logical_plan: |
    LogicalProject { exprs: [$0, $1, $3, $4] }
      LogicalJoin { type: Inner, on: ($0 = $3), output_indices: all }
        LogicalProject { exprs: [$1, $2] }
          LogicalScan { table: t, columns: [_row_id, v1, v2] }
        LogicalScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    /* alias less columns than available */
    create table t (v1 bigint, v2 double precision);
    select * from (select * from t) as tt(a) join t on a=v1;
  logical_plan: |
    LogicalProject { exprs: [$0, $1, $3, $4] }
      LogicalJoin { type: Inner, on: ($0 = $3), output_indices: all }
        LogicalProject { exprs: [$1, $2] }
          LogicalScan { table: t, columns: [_row_id, v1, v2] }
        LogicalScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    /* alias more columns than available */
    create table t (v1 bigint, v2 double precision);
    select * from (select * from t) as tt(a, b, c) join t on a=v1;
  binder_error: 'Bind error: table "tt" has less columns available but more aliases specified'
- sql: |
    create table t(x int);
    select * from t, (select * from t as t2 order by t.x desc) as t3;
  binder_error: 'Item not found: Invalid column: x'
- sql: |
    create table t(x int);
    select * from t, (select t.x) as t1;
  binder_error: 'Item not found: Invalid column: x'
- sql: |
    create table t(x int);
    select * from t JOIN (select t.x) as t1;
  binder_error: 'Item not found: Invalid column: x'
- sql: |
    /* We should be able to handle nested correlated subquery */
    /* Our optimizer cannot unnest `CorrelatedInputRef` at depth >= 2 */
    create table ab (a int, b int);
    create table bc (b int, c int);
    create table t (v1 int, v2 varchar);
    select * from ab where exists (
      select * from bc, (
          select * from t where v1 = a
      ) as t0
    );
  logical_plan: |
    LogicalProject { exprs: [$1, $2] }
      LogicalApply { type: LeftSemi, on: true }
        LogicalScan { table: ab, columns: [_row_id, a, b] }
        LogicalProject { exprs: [$1, $2, $3, $4] }
          LogicalJoin { type: Inner, on: true, output_indices: all }
            LogicalScan { table: bc, columns: [_row_id, b, c] }
            LogicalProject { exprs: [$1, $2] }
              LogicalFilter { predicate: ($1 = CorrelatedInputRef { index: 1, depth: 2 }) }
                LogicalScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    /* Reference to left table should be permitted with lateral */
    create table a (x int);
    create table b (y int);
    select * from a, lateral (select * from b where x = y);
  logical_plan: |
    LogicalProject { exprs: [$1, $2] }
      LogicalApply { type: Inner, on: true }
        LogicalScan { table: a, columns: [_row_id, x] }
        LogicalProject { exprs: [$1] }
          LogicalFilter { predicate: (CorrelatedInputRef { index: 1, depth: 1 } = $1) }
            LogicalScan { table: b, columns: [_row_id, y] }
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: ($0 = $2), output_indices: [0, 1] }
      LogicalScan { table: a, columns: [x] }
      LogicalProject { exprs: [$0, $0] }
        LogicalScan { table: b, columns: [y] }
- sql: |
    /* We need to ensure doubly nested reference to a left table is not permitted */
    create table ab (a int, b int);
    create table bc (b int, c int);
    create table t (v1 int, v2 int);
    select * from ab, (
      select * from bc, (
          select * from t where v1 = a
      ) as t0
    );
  binder_error: 'Item not found: Invalid column: a'
- sql: |
    /* Doubly nested reference to a left table with lateral is permitted */
    /* Our optimizer cannot unnest `CorrelatedInputRef` at depth >= 2 */
    create table ab (a int, b int);
    create table bc (b int, c int);
    create table t (v1 int, v2 int);
    select * from ab, lateral (
      select * from bc, (
          select * from t where v1 = a
      ) as t0
    );
  logical_plan: |
    LogicalProject { exprs: [$1, $2, $3, $4, $5, $6] }
      LogicalApply { type: Inner, on: true }
        LogicalScan { table: ab, columns: [_row_id, a, b] }
        LogicalProject { exprs: [$1, $2, $3, $4] }
          LogicalJoin { type: Inner, on: true, output_indices: all }
            LogicalScan { table: bc, columns: [_row_id, b, c] }
            LogicalProject { exprs: [$1, $2] }
              LogicalFilter { predicate: ($1 = CorrelatedInputRef { index: 1, depth: 2 }) }
                LogicalScan { table: t, columns: [_row_id, v1, v2] }
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: ($0 = $2), output_indices: [0, 1, 3, 4, 5, 6] }
      LogicalScan { table: ab, columns: [a, b] }
      LogicalProject { exprs: [$0, $1, $2, $3, $4] }
        LogicalJoin { type: Inner, on: true, output_indices: all }
          LogicalJoin { type: Inner, on: true, output_indices: all }
            LogicalAgg { group_key: [0], agg_calls: [] }
              LogicalScan { table: ab, columns: [a] }
            LogicalScan { table: bc, columns: [b, c] }
          LogicalScan { table: t, output_columns: [_row_id, v1], required_columns: [$0:_row_id, $1:v1], predicate: ($1 = CorrelatedInputRef { index: 1, depth: 2 }) }
